var documenterSearchIndex = {"docs":
[{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Clipper","category":"page"},{"location":"reference/#Public-functions","page":"Reference","title":"Public functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Clipper]\nPrivate = false","category":"page"},{"location":"reference/#Clipper.IntPoint-Tuple{Union{Float16, Float32, Float64}, Union{Float16, Float32, Float64}, Int64, Int64}","page":"Reference","title":"Clipper.IntPoint","text":"IntPoint(x, y)\n\nCreate an IntPoint from integer values.\n\nIntPoint(x, y, magnitude, precision)\n\nCreate an IntPoint from floating point values with the given number of digits of precision. magnitude = number of digits above zero (90 => 2, 9 => 1, 0.9 => 0, 0.09 => -1) sigdigits = number of digits to preserve (94.3856 with 4 => 94.39)\n\na = IntPoint(5.483, 55.8739, 2, 4) # [548, 5587]\nb,c = tofloat(a, 2, 4)             # 5.48, 55.87\n\n\n\n\n\n","category":"method"},{"location":"reference/#Clipper.tofloat-Tuple{IntPoint, Int64, Int64}","page":"Reference","title":"Clipper.tofloat","text":"tofloat(intpoint, magnitude, precision)\n\nRestore an IntPoint to floating point values using the specified magnitude and precision. magnitude = number of digits to be above zero (90 => 2, 9 => 1, 0.9 => 0, 0.09 => -1) sigdigits = number of digits that were preserved (94.3856 with 4 => 94.39)\n\n\n\n\n\n","category":"method"},{"location":"#Clipper.jl","page":"Home","title":"Clipper.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Clipper.jl is a Julia wrapper for Angus Johnson's Clipper library (ver. 6.4.2).","category":"page"},{"location":"","page":"Home","title":"Home","text":"It can be used for the following two tasks:","category":"page"},{"location":"","page":"Home","title":"Home","text":"offsetting a polygon \ncompute boolean operations between two or more polygons","category":"page"},{"location":"#General-description-of-a-polygon","page":"Home","title":"General description of a polygon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A polygon consists of a list of vertices v_1 dots v_n such that v_1 is connected to v_2 and v_n. v_i is connected to v_i-1 and v_i+1. All functionality in Clipper only works with vertices that have discrete coordinates. Therefore the struct IntPoint is used. Points which consist of two floating point coordinates can however be easily converted using the IntPoint method.","category":"page"},{"location":"","page":"Home","title":"Home","text":"p = (1.1, 2.1)\nip = IntPoint(p..., 1, 3) # [110, 210]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Here 1 is the magnitude and 3 is the number of significant digits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There is also the function tofloat which can be used to convert a IntPoint back to the floating point coordinates.","category":"page"},{"location":"","page":"Home","title":"Home","text":"tofloat(ip, 1, 3) # (1.1, 2.1)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Using broadcasting you can also easily convert several points like a whole polygon this way:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ps = rand(100, 2) \nips = IntPoint.(ps[:,1], ps[:,2], 1, 3)","category":"page"},{"location":"","page":"Home","title":"Home","text":"and back","category":"page"},{"location":"","page":"Home","title":"Home","text":"tofloat.(ips, 1, 3)","category":"page"},{"location":"#Offsetting-a-polygon","page":"Home","title":"Offsetting a polygon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Original Clipper documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A polygon can be offset (inflated/deflated) in the following way using Clipper.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"polygon = IntPoint[]\npush!(polygon, IntPoint(348,257))\npush!(polygon, IntPoint(364,148))\npush!(polygon, IntPoint(362,148))\npush!(polygon, IntPoint(326,241))\npush!(polygon, IntPoint(295,219))\npush!(polygon, IntPoint(258,88))\npush!(polygon, IntPoint(440,129))\npush!(polygon, IntPoint(370,196))\npush!(polygon, IntPoint(372,275))\n\nco = ClipperOffset()\nadd_path!(co, polygon, JoinTypeRound, EndTypeClosedPolygon)\noffset_polygons = execute(co, -7.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"# using Luxor\n# fpolygon = Point.(tofloat.(polygon, 3,3))\n# foffset_polygons = [Point.(tofloat.(offset_polygon, 3,3)) for offset_polygon in offset_polygons]\n# @png begin\n#     translate(-650, -400)\n#     scale(2)\n#     sethue(\"blue\")\n#     poly(fpolygon, :stroke, close=true)\n#     sethue(\"green\")\n#     setopacity(0.4)\n#     poly.(foffset_polygons, :fill, close=true)\n# end 600 600 \"offset_in.png\"","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Offset polygon) In the image above the blue polygon is the initial polygon and by offsetting it two polygons are created which are drawn as the filled green polygons.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can also inflate the polygon by using a positive value in the execute function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"offset_polygons = execute(co, 7.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Inflating the polygon)","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this example we can visualize the meaning of the third argument in the add_path! function which is currently set to JoinTypeRound.","category":"page"},{"location":"","page":"Home","title":"Home","text":"co = ClipperOffset()\nadd_path!(co, polygon, JoinTypeRound, EndTypeClosedPolygon)\nround_offset_polygons = execute(co, 7.0)\n\nco = ClipperOffset()\nadd_path!(co, polygon, JoinTypeSquare, EndTypeClosedPolygon)\nsquare_offset_polygons = execute(co, 7.0)\n\nco = ClipperOffset()\nadd_path!(co, polygon, JoinTypeMiter, EndTypeClosedPolygon)\nmiter_offset_polygons = execute(co, 7.0)","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Different offsetting types)","category":"page"},{"location":"","page":"Home","title":"Home","text":"JoinTypeRound produces rounded corners, JoinTypeSquare produces squared corners. In the case of JoinTypeMiter it depends on the degree of the angle or in different words the maximum offsetted distance if corners. would not be squared. If the maximum distance is bigger than MiterLimit * delta than it is squared which would be the case in the upper right corner.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The MiterLimit is the first argument of ClipperOffset for example ClipperOffset(3.0) would set it to 3.0 (default is 2.0). delta is simply the distance we want to offset in our case above we set it to 7.0 as the second parameter of the execute function.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The three different types are also explained in the official documentation.","category":"page"},{"location":"#Boolean-operations-between-two-or-more-polygons","page":"Home","title":"Boolean operations between two or more polygons","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Needs to be written. Feel free to open a PR.","category":"page"}]
}
